---
image: kloiadocker/docker-compose:v1

services:
  - docker:18.09-dind

stages:
  - build-jar
  - build
  - test
  - push
  - deploy

variables:
  AWS_ACCESS_KEY_ID: "${AWS_ACCESS_KEY_ID_DEV}"
  AWS_SECRET_ACCESS_KEY: "${AWS_SECRET_ACCESS_KEY_DEV}"
  BUILD_ROOT: "${CI_PROJECT_DIR}"
  BUILD_TAG: "${CI_PIPELINE_ID}"
  DOCKER_DRIVER: overlay2
  DOCKER_HOST: tcp://localhost:2375

before_script:
  - |
    # Export Vars
    export BUILD_TIMESTAMP="$(date '+%Y%m%d.%H%M')"

    # Create directories

    mkdir -p ~/.ssh
    chmod 700 ~/.ssh

    # AWS Cli
    mkdir -p ~/.aws

    # Configure AWS credentials
    echo -e "[flo-dev]\naws_access_key_id=$AWS_ACCESS_KEY_ID\naws_secret_access_key=$AWS_SECRET_ACCESS_KEY\nregion=us-west-2" > ~/.aws/credentials
    # Login to ECR for docker images
    eval "$(aws ecr get-login --profile=flo-dev --no-include-email)"



    ##
    ## Run ssh-agent (inside the build environment)
    ##
    eval $(ssh-agent -s)

    ##
    ## Add the SSH key stored in SSH_PRIVATE_KEY variable to the agent store
    ## We're using tr to fix line endings which makes ed25519 keys work
    ## without extra base64 encoding.
    ## https://gitlab.com/gitlab-examples/ssh-private-key/issues/1#note_48526556
    ##

    if [[ ! -z "${SSH_PRIVATE_KEY:-}" ]]
    then
     echo "${SSH_PRIVATE_KEY}" | tr -d '\r' | ssh-add - > /dev/null
     mkdir -p "${HOME}/.ssh"
     echo "${SSH_PRIVATE_KEY}" > "${HOME}/id_rsa" && chmod 400 "${HOME}/id_rsa" && echo "SSH Key is in ${HOME}/id_rsa"
    fi


    # Add authorized ssh keys for the builder:
    echo "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDcFXCVFXrhfomC3USHPTLJ8XMJuu0crigWXpFGh59Z3NCML2GR5NcUWhBChZrQ4PUfZeUzYIulOvacgDyBzVglnMOEe/u7SYxlj8+akbanH4yoWlHSaxld0POV/a9iz/+yGLH2yJeSFmkxFzARycM/x1f4XrBNXyBUMSIwwTf44o0KntnZ4gdHmCwFMF0wY7cpACbZVAwRGV6ffvfregCHyYKxDw8/pL1Opg92GhXNXh9219evPgF1tFTtlakUG/f8zBLTi8OjBW3JTKK6xCkVp0K6323QXBLUwGS78sIIpjvBpYB3vsLQoX+IsRJTelZI1826ygMpb6wG4DpDA0Kb dmitry@Dmitrys-MBP-Flo" >> "${HOME}/.ssh/authorized_keys"

    # Ensure github key is known
    echo "github.com ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAq2A7hRGmdnm9tUDbO9IDSwBK6TbQa+PXYPCPy6rbTrTtw7PHkccKrpp0yVhp5HdEIcKr6pLlVDBfOLX9QUsyCOV0wzfjIJNlGEYsdlLJizHhbn2mUjvSAHQqZETYP81eFzLQNnPHt4EVVUh7VfDESU84KezmD5QlWpXLmvU31/yMf+Se8xhHTvKSCZIFImWwoG6mbUoWf9nzpIoaSjB+weqqUUmpaaasXVal72J+UX2B+2RPW3RcT0eOzQgqlJL3RKrTJvdsjE3JEAvGq3lGHSZXy28G3skua2SmVi/w4yCE6gbODqnTWlg7+wC604ydGXA8VJiS5ap43JXiUFFAaQ==" >> "${HOME}/.ssh/known_hosts"

    echo "Syncing Submodules"
    cd ${CI_PROJECT_DIR}
    git submodule sync --recursive
    git submodule update --init --recursive


BuildJar:
  before_script:
    - 'echo BuildingJar. ... '
  image: 098786959887.dkr.ecr.us-west-2.amazonaws.com/flo-scala-docker:SCALA_2.12.2-SBT_1.0.1-alpine-build
  stage: build-jar
  artifacts:
    paths:
      - target/scala-*/app.jar
      - bin/
      - build
      - "*/build"
      - logs/


    expire_in: 1 week
  script:
    - |
      sbt assembly
  tags:
    - build


Compile:
  stage: build
  except:
    - tags
  artifacts:
    paths:
      # Docker Image
      - image

      # Scala
      - target/scala-*/app.jar

      # Golang
      - bin/

      # Gradle
      - build
      - "*/build"
      - logs/


    expire_in: 1 week
    # Cache modules in between jobs
  cache:
    key: "$CI_PROJECT_NAME-$CI_COMMIT_REF_SLUG"
    paths:
      - target
      - .ivy2
      - .sbt
      - .gradle
      - pkg

  variables:
    USER: ubuntu

  script:
    - |
      source .ci/.env.rc
      set -euo pipefail

      # In case we don't have .ebextensions
      mkdir -p $BUILD_ROOT/.ebextensions/

      # Copy .ebextentions
      cp -R $BUILD_ROOT/.app/.ebextensions/* $BUILD_ROOT/.ebextensions/

      # Logig to ECR
      eval $(aws ecr get-login --profile=flo-dev --no-include-email)

      # Run app build
      docker-compose run build

      docker-compose build app

      # Ensure tags are set
      docker tag ${AWS_ECR_REPOSITORY}/${CI_PROJECT_NAME} ${AWS_ECR_REPOSITORY}/${CI_PROJECT_NAME}:latest
      docker tag ${AWS_ECR_REPOSITORY}/${CI_PROJECT_NAME} ${AWS_ECR_REPOSITORY}/${CI_PROJECT_NAME}:${CI_PIPELINE_ID}
      mkdir -p image && docker save ${AWS_ECR_REPOSITORY}/${CI_PROJECT_NAME} > image/${CI_PROJECT_NAME}_${CI_PIPELINE_ID}.tar



Sanity:
  stage: test
  dependencies:
    - Compile
  script: |
    ./.app/.ci/test.sh

ECR:
  stage: push
  dependencies:
    - Compile
  script: |
    source .ci/.env.rc
    set -euo pipefail

    docker load < image/${CI_PROJECT_NAME}_${CI_PIPELINE_ID}.tar
    docker push ${AWS_ECR_REPOSITORY}/${CI_PROJECT_NAME}:latest
    docker push ${AWS_ECR_REPOSITORY}/${CI_PROJECT_NAME}:${CI_PIPELINE_ID}


dev:
  stage: deploy
  dependencies:
    - Compile
  except:
    - master
  environment:
    name: dev
    url: https://kibana.flotech.co
  script: |
    ./.app/.ci/deploy.sh


prod:
  stage: deploy
  dependencies:
    - Compile
  only:
    - master
  environment:
    name: prod
    url: https://kibana.flotech.co
  script: |
    ./.app/.ci/deploy.sh
