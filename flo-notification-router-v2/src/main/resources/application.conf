include "akka-kafka-consumer.conf"
include "akka-kafka-committer.conf"
include "akka-kafka-producer.conf"

notification-router {

  kafka {
    hosts = ${KAFKA_HOSTS}

    alarm-incident-consumer {
      group-id = ${ALARM_INCIDENT_CONSUMER_GROUP_ID}
      topic = ${ALARM_INCIDENT_CONSUMER_TOPIC}
      poll-timeout = ${ALARM_INCIDENT_CONSUMER_POLL_TIMEOUT}
      parallelism = ${?ALARM_INCIDENT_CONSUMER_PARALLELISM}
      parallelism = 50
    }

    alert-status-consumer {
      group-id = ${ALERT_STATUS_CONSUMER_GROUP_ID}
      topic = ${ALERT_STATUS_CONSUMER_TOPIC}
      poll-timeout = ${ALERT_STATUS_CONSUMER_POLL_TIMEOUT}
      parallelism = ${?ALERT_STATUS_CONSUMER_PARALLELISM}
      parallelism = 50
    }

    entity-activity-consumer {
      group-id = ${ENTITY_ACTIVITY_CONSUMER_GROUP_ID}
      topic = ${ENTITY_ACTIVITY_CONSUMER_TOPIC}
      poll-timeout = ${ENTITY_ACTIVITY_CONSUMER_POLL_TIMEOUT}
      parallelism = ${?ENTITY_ACTIVITY_CONSUMER_PARALLELISM}
      parallelism = 50
    }

    entity-activity-producer.topic = ${ENTITY_ACTIVITY_PRODUCER_TOPIC}
  }

  server {
    port = 8000
    port = ${?SERVER_PORT}

    health-check-path = /ping
    health-check-path = ${?SERVER_HEALTH_CHECK_ENDPOINT}
  }

  default-time-zone = "America/Los_Angeles"

  alarm-filters {
    expiration-filter {
      alarm-expiration = 30d
    }

    sleep-mode-filter {
      exceptions = [ 3, 4, 5, 28, 29, 30, 31, 32, 33, 34, 35, 36, 38, 39, 40, 41, 42, 43, 47, 48, 50, 56, 91 ]
    }

    flo-sense-filter {
      shutoff-exceptions = [ 10, 11, 26]
      flo-sense-alarms = [ 70, 71, 72, 73, 74, 75, 76, 77, 78, 79 ]
    }

    default-do-not-disturb-settings {
      starts-at = "23:00"
      starts-at = ${?DND_START_TIME}
      ends-at = "07:00"
      ends-at = ${?DND_END_TIME}
      allow-email = true
      allow-sms = false
      allow-push-notification = false
      allow-voice-call = false
      allowed-severities = [ 1 ] # "Critical" severity allowed during DND time.
    }
  }

  email {
    callback-hook = ${EMAIL_INTERNAL_STATUS_HOOK_URL}
    email-gateway-url = ${EMAIL_GATEWAY_URL}
    email-gateway-url-queue-path = "/queue"
    email-gateway-url-queue-method = "POST"
  }

  sms {
    delivery-callback = ${SMS_INTERNAL_STATUS_HOOK_URL}
    post-delivery-callback = ${SMS_STATUS_HOOK_URL}
    topic = ${SMS_TOPIC}
  }

  voice {
    topic = ${VOICE_TOPIC}
    gather-url = ${FLO_CALLBACK_GATEWAY_URL}"/twilio/voice/:userId/:alarmIncidentId"
    status-callback-url = ${FLO_CALLBACK_GATEWAY_URL}"/twilio/voice/:userId/:alarmIncidentId"
  }

  push {
    topic = ${PUSH_TOPIC}
  }
}

task-scheduler {
  url = "http://flo-task-scheduler-v2.flo-task-scheduler-v2.svc.cluster.local"
  url = ${?TASK_SCHEDULER_URL}
}

localization {
  default-time-zone = "America/Los_Angeles"
  default-date-time-format = "MMMM d 'at' h:mm a"
  cache {
    max-size = 10000
    expire-after-write = 30m
  }
}


redis {
  host = ${REDIS_HOST}
  port = 6379
  port = ${?REDIS_PORT}
}

postgres-db-context {
  dataSourceClassName=org.postgresql.ds.PGSimpleDataSource
  dataSource.user=${DB_USER}
  dataSource.password=${DB_PASSWORD}
  dataSource.databaseName=${DB_NAME}
  dataSource.portNumber=${DB_PORT}
  dataSource.serverName=${DB_HOST}
  connectionTimeout=10000
}

fire-writer {
  url = ${FLO_FIRE_WRITER_URL}
}

akka {
  http {
    host-connection-pool {
      max-open-requests = 1024
      idle-timeout = 10s
      client {
        connecting-timeout = 1s
        idle-timeout = 10s
      }
    }
  }
}

mqtt {
  broker = ${?MQTT_BROKER},
  qos = 2,
  client-id = "notification-router",
  ssl-configuration {
    aws-config-bucket: ${?AWS_CONFIG_BUCKET}
    client-cert = ${?MQTT_CLIENT_CERT},
    client-key = ${?MQTT_CLIENT_KEY},
    broker-ca-certificate = ${?MQTT_CA_CERTIFICATE}
  }
}
